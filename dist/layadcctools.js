(()=>{"use strict";var t={d:(e,r)=>{for(var i in r)t.o(r,i)&&!t.o(e,i)&&Object.defineProperty(e,i,{enumerable:!0,get:r[i]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{LayaDCC:()=>q,LayaDCCTools:()=>ht,PackRaw:()=>ft,Params:()=>G});const r=require("path"),i=require("util"),n=require("fs"),s=require("zlib");class a{constructor(){this.repoPath=""}fetch(t){throw new Error("Method not implemented.")}async init(t,e){this.repoPath=t}async read(t,e,s){if(r.isAbsolute(t)||(t=r.join(this.repoPath,t)),"buffer"===e){const e=await(0,i.promisify)(n.readFile)(t);return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}return(0,i.promisify)(n.readFile)(t,"utf8")}async write(t,e,s){r.isAbsolute(t)&&(t=r.relative(this.repoPath,t));let a=t.split("/");a.pop();let o=r.resolve(this.repoPath,t),l=r.resolve(this.repoPath,a.join("/"));try{if(!s&&n.existsSync(o))return;await(0,i.promisify)(n.access)(l)}catch(t){await(0,i.promisify)(n.mkdir)(l,{recursive:!0})}if(e instanceof ArrayBuffer)return(0,i.promisify)(n.writeFile)(o,Buffer.from(e));await(0,i.promisify)(n.writeFile)(o,e)}async isFileExist(t){try{return await(0,i.promisify)(n.access)(t,n.constants.F_OK),!0}catch(t){return!1}}unzip(t){if(!(t instanceof ArrayBuffer))throw new Error("Input must be an ArrayBuffer.");const e=Buffer.from(t);return(0,s.gunzipSync)(e).buffer}zip(t){if(!(t instanceof ArrayBuffer))throw new Error("Input must be an ArrayBuffer.");const e=Buffer.from(t);return(0,s.gzipSync)(e).buffer}textencode(t){return Buffer.from(t,"utf-8").buffer}textdecode(t,e){if(!(t instanceof ArrayBuffer))throw new Error("Input must be an ArrayBuffer.");return Buffer.from(t).toString("utf-8",e)}async mv(t,e){return(0,i.promisify)(n.rename)(t,e)}rm(t){let e=r.resolve(this.repoPath,t);return(0,i.promisify)(n.rm)(e)}async enumCachedObjects(t){let e=r.join(this.repoPath,"objects"),i=n.readdirSync(e);for(let r of i){let i=e+"/"+r,s=n.readdirSync(i);for(let e of s)t(r+e)}}}var o="undefined"==typeof window&&"object"==typeof global;class l{static get runtimeName(){return o?"node":window.conch?"layaNative":"web"}static isNative(){}static isWeb(){}static isNode(){}static dcodeUtf8(t){if(window.conch){let e=function(t){let e=0;var r,i,n=t.byteLength,s=String.fromCharCode,a=new Uint8Array(t),o=[],l=0;for(o.length=1e3;e<n;)if((r=a[e++])<128)0!=r&&(o[l++]=s(r));else if(r<224)o[l++]=s((63&r)<<6|127&a[e++]);else if(r<240)i=a[e++],o[l++]=s((31&r)<<12|(127&i)<<6|127&a[e++]);else{const t=(15&r)<<18|(127&(i=a[e++]))<<12|(127&a[e++])<<6|127&a[e++];if(t>=65536){const e=t-65536,r=55296|e>>10,i=56320|1023&e;o[l++]=s(r),o[l++]=s(i)}else o[l++]=s(t)}return o.length=l,o.join("")}(t);return e}return(new TextDecoder).decode(t)}}const c=[1518500249,1859775393,-1894007588,-899497514],h={sha1:1};function f(t){if(t&&!h[t]&&!h[t.toLowerCase()])throw new Error("Digest method not supported");return new d}class d{constructor(){this.A=1732584193,this.B=-271733879,this.C=-1732584194,this.D=271733878,this.E=-1009589776,this._size=0,this._sp=0,(!w||y>=8e3)&&(w=new ArrayBuffer(8e3),y=0),this._byte=new Uint8Array(w,y,80),this._word=new Int32Array(w,y,20),y+=80}update(t){if("string"==typeof t)return this._utf8(t);if(null==t)throw new TypeError("Invalid type: "+typeof t);const e=t.byteOffset,r=t.byteLength;let i=r/64|0,n=0;if(i&&!(3&e)&&!(this._size%64)){const r=new Int32Array(t.buffer,e,16*i);for(;i--;)this._int32(r,n>>2),n+=64;this._size+=n}if(1!==t.BYTES_PER_ELEMENT&&t.buffer){const i=new Uint8Array(t.buffer,e+n,r-n);return this._uint8(i)}return n===r?this:this._uint8(t,n)}_uint8(t,e){const{_byte:r,_word:i}=this,n=t.length;for(e|=0;e<n;){const s=this._size%64;let a=s;for(;e<n&&a<64;)r[a++]=t[e++];a>=64&&this._int32(i),this._size+=a-s}return this}_utf8(t){const{_byte:e,_word:r}=this,i=t.length;let n=this._sp;for(let s=0;s<i;){const a=this._size%64;let o=a;for(;s<i&&o<64;){let r=0|t.charCodeAt(s++);r<128?e[o++]=r:r<2048?(e[o++]=192|r>>>6,e[o++]=128|63&r):r<55296||r>57343?(e[o++]=224|r>>>12,e[o++]=128|r>>>6&63,e[o++]=128|63&r):n?(r=((1023&n)<<10)+(1023&r)+65536,e[o++]=240|r>>>18,e[o++]=128|r>>>12&63,e[o++]=128|r>>>6&63,e[o++]=128|63&r,n=0):n=r}o>=64&&(this._int32(r),r[0]=r[16]),this._size+=o-a}return this._sp=n,this}_int32(t,e){let{A:r,B:i,C:n,D:s,E:a}=this,o=0;for(e|=0;o<16;)u[o++]=m(t[e++]);for(o=16;o<80;o++)u[o]=p(u[o-3]^u[o-8]^u[o-14]^u[o-16]);for(o=0;o<80;o++){const t=o/20|0,e=b(r)+(h=i,f=n,d=s,0===(l=t)?h&f|~h&d:2===l?h&f|h&d|f&d:h^f^d)+a+u[o]+c[t]|0;a=s,s=n,n=_(i),i=r,r=e}var l,h,f,d;this.A=r+this.A|0,this.B=i+this.B|0,this.C=n+this.C|0,this.D=s+this.D|0,this.E=a+this.E|0}digest(t){const{_byte:e,_word:r}=this;let i=this._size%64|0;for(e[i++]=128;3&i;)e[i++]=0;if(i>>=2,i>14){for(;i<16;)r[i++]=0;i=0,this._int32(r)}for(;i<16;)r[i++]=0;const n=8*this._size,s=(4294967295&n)>>>0,a=(n-s)/4294967296;return a&&(r[14]=m(a)),s&&(r[15]=m(s)),this._int32(r),"hex"===t?this._hex():this._bin()}_hex(){const{A:t,B:e,C:r,D:i,E:n}=this;return g(t)+g(e)+g(r)+g(i)+g(n)}_bin(){const{A:t,B:e,C:r,D:i,E:n,_byte:s,_word:a}=this;return a[0]=m(t),a[1]=m(e),a[2]=m(r),a[3]=m(i),a[4]=m(n),s.slice(0,20)}}const u=new Int32Array(80);let w,y=0;const g=t=>(t+4294967296).toString(16).substr(-8),m=254===new Uint8Array(new Uint16Array([65279]).buffer)[0]?t=>t:t=>t<<24&4278190080|t<<8&16711680|t>>8&65280|t>>24&255,p=t=>t<<1|t>>>31,b=t=>t<<5|t>>>27,_=t=>t<<30|t>>>2;function j(t){return l.dcodeUtf8(t)}function k(t,e,r){let i=(new TextEncoder).encode(e);return t.set(i,r),i.length}let P=null;function A(t){let e="";for(const r of new Uint8Array(t))r<16&&(e+="0"),e+=r.toString(16);return e}function v(t){const e=t.padStart(40,"0");let r=new Uint8Array(20);for(let t=0;t<20;t++)r[t]=parseInt(e.substring(2*t,2*t+2),16);return r}async function O(t,e=!0){return null===P&&(P=await async function(){try{if("da39a3ee5e6b4b0d3255bfef95601890afd80709"===await S(new Uint8Array([])))return!0}catch(t){}return!1}()),P?S(t,e):function(t,e=!0){let r;return r=e?f().update(t).digest("hex"):f().update(t).digest(),r}(t,e)}async function S(t,e=!0){const r=new Uint8Array(await crypto.subtle.digest("SHA-1",t));return e?A(r):r}class U{constructor(){this.parent="0"}}class E{constructor(t,e){t instanceof ArrayBuffer?(this.commitinfo=new U,this.parse(t),this.commitinfo.sha=e):this.commitinfo=t}readString(t,e,r){let i=r>0?r:t.byteLength;return t=t.slice(e,e+i),j(new Uint8Array(t))}strToBuff(t){return(new TextEncoder).encode(t)}getStrLen(t,e,r=-1){let i=0;for(let n=0;n<r&&0!==t[e+n];n++)i++;return i}parse(t){let e=this.commitinfo,r=new Uint8Array(t),i=0;if("commit "!==this.readString(r,i,7))return!1;i+=7;let n=this.readString(r,i,this.getStrLen(r,i,100));i+=n.length+1;let s=this.readString(r,i,parseInt(n)),a=s.indexOf("tree ");if(a<0)return!1;let o=s.substr(a+5,40);e.tree=o;let l=s.indexOf("parent ",a+40);if(l<0)return!1;let c=s.substr(l+7,40);return e.parent=c,e.commitMessage=s.substr(l+7+40+1),!0}idbuffToString(t){return t instanceof ArrayBuffer?A(new Uint8Array(t)):t instanceof Uint8Array?A(t):t}formatDate(t){return t.getFullYear()+"-"+(t.getMonth()+1)+"-"+t.getDate()+" "+t.getHours()+":"+t.getMinutes()+":"+t.getSeconds()}async toBuffer(t){let e=this.idbuffToString(this.commitinfo.tree),r=this.commitinfo.parent?this.idbuffToString(this.commitinfo.parent):null,i="commit ",n="";n+="tree "+e+"a",r&&(n+="parent "+r+"a"),n+="author "+this.commitinfo.author+" "+this.formatDate(this.commitinfo.author_timestamp)+" \n\n "+this.commitinfo.commitMessage+"\n",i+=(new TextEncoder).encode(n).length,i+="\0",i+=n;let s=this.strToBuff(i);return t.zip&&(s=new Uint8Array(t.zip(s))),this.commitinfo.sha=await O(s,!0),s}}var x,C=".projinfo";class N{constructor(t){this.treeRoot=new F(null,null,null),this.curCommit=new U,this.allchanges=[],this.checkDownload=!1,this._objectPacks=[],this.objectEncrypter=null,this.frw=t}addObjectPack(t,e=!1){this._objectPacks.indexOf(t)<0&&(e&&this._objectPacks.splice(0,0,t),this._objectPacks.push(t))}removeObjectPack(t){let e=this._objectPacks.indexOf(t);e>=0&&this._objectPacks.splice(e,1)}clearObjectPack(){this._objectPacks.length=0}getObjUrl(t){let e=N.OBJSUBDIRNUM,r="objects/",i=t;for(let t=0;t<e;t++){let t=i.substring(0,2);i=i.substring(2),r+=t,r+="/"}return r+=i,r}getCurCommit(){return this.curCommit.sha}async initByLastCommit(){}async getCommitHead(t){let e=await this.frw.read(t,"utf8",!1);if(e)return this.recentCommits=e.split("\n"),this.recentCommits[0];throw"no commit"}async initByCommitID(t){if(!t)return!1;let e=await this.getCommit(t);if(!e)return!1;let r=e.commitinfo.tree;return this.treeRoot=await this.getTreeNode(r,this.treeRoot),this.curCommit.tree=r,this.curCommit.parent=e.commitinfo.parent,this.curCommit.commitMessage=e.commitinfo.commitMessage,this.curCommit.sha=t,!0}async setRoot(t){try{this.treeRoot=await this.getTreeNode(t,this.treeRoot)}catch(t){this.treeRoot=null}return!!this.treeRoot}async toRev(t){}async getCommit(t){let e,r=this.getObjUrl(t),i=await this.frw.read(r,"buffer",!1);return i?(e=new E(this.frw.unzip(i),t),e):null}async loadAllPack(){}async getTreeNode(t,e){if(!t)return new F(null,null,this.frw);let r,i=this.getObjUrl(t);try{r=await this.frw.read(i,"buffer",!1)}catch(t){}if(!r){for(let e of this._objectPacks)if(e&&(await e.has(t)&&(r=await e.get(t)),r))break;if(!r)throw"no treepath"}let n=new Uint8Array(r),s=e;return s?s.parseBuffer(n,this.frw):s=new F(n,null,this.frw),s.sha=t,s}async getBlobNode(t,e){let r=t;"string"!=typeof t&&(r=A(t));let i=this.getObjUrl(r),n=null;try{let t=await this.frw.read(i,"buffer",!1);t&&(n=N.zip?this.frw.unzip(t):t)}catch(t){}if(!n){for(let t of this._objectPacks)if(t&&(await t.has(r)&&(n=await t.get(r)),n))break;if(!n)throw new Error("download error:"+r)}if(this.checkDownload){let t=await O(new Uint8Array(n),!0);t!=r&&console.log("下载的文件校验错误:",r,t)}return"utf8"==e?j(n):n}async openNode(t){if(t.treeNode)return t.treeNode;t instanceof D||console.error("openNode param error!");try{if(t.isDir){let e=await this.getTreeNode(t.idstring,null);return t.treeNode=e,e.parent=t.owner,e}return null}catch(t){throw"open node error"}}async visitAll(t,e,r){await e(t);for await(const i of t.entries)if(i.isDir)try{i.treeNode||await this.openNode(i),await this.visitAll(i.treeNode,e,r)}catch(t){console.log("openNode error:",A(i.oid))}else await r(i)}async loadFile(t,e,r){let i;return"string"==typeof t?await this.loadFileByPath(t,e):(t instanceof F?i=t.getEntry(e):t instanceof D&&(i=t,r=e),i?await this.getBlobNode(i.idstring,r):(console.log("没有这个文件:",e),null))}async loadFileByPath(t,e){let r=[];if(await this.pathToEntries(t,r)){let t=r[r.length-1];return await this.getBlobNode(t.idstring,e)}return null}async saveBlobNode(t,e,r){return e.byteLength>N.MAXFILESIZE?(alert("文件太大，无法上传："+r+"\n限制为："+N.MAXFILESIZE/1024/1024+"M"),!1):(await this.saveObject(t,e),!0)}async saveObject(t,e){let r=this.getObjUrl(t);this.objectEncrypter&&(e=this.objectEncrypter.encode(e)),await this.frw.write(r,e,!0)}async sha1(t){return"string"==typeof t&&(t=(new TextEncoder).encode(t).buffer),await O(new Uint8Array(t),!0)}async pathToEntries(t,e){let r=t.split("/"),i=this.treeRoot;e.length=0;for await(let t of r){if(""==t)continue;if("."==t)continue;".."==t&&(i=i.parent);let r=i.getEntry(t);if(!r)return!1;e.push(r),r.isDir&&!(i=r.treeNode)&&(i=await this.openNode(r))}return!0}async pathToObjPath(t){let e=[];if(await this.pathToEntries(t,e)){let t=A(e[e.length-1].oid);return this.getObjUrl(t)}return null}async getNodeByPath(t,e=!1,r=null){let i=t.split("/"),n=r||this.treeRoot;for(let t=0,r=i.length;t<r;t++){let r=i[t];if(""==r)continue;if("."==r)continue;".."==r&&(n=n.parent);let s=n.getEntry(r);if(s)n=s.treeNode?s.treeNode:await this.openNode(s);else{if(!e)return null;{let t=n.addEntry(r,!0,null);n=new F(null,n,this.frw),t.treeNode=n,n.needSha()}}}return n}async setFileAtNode(t,e,r){let i;i=r instanceof ArrayBuffer?r:r instanceof File?await async function(t){return new Promise(((e,r)=>{let i=new FileReader;i.onload=async t=>{let r=t.target.result;e(r)},i.onerror=function(t){e(null)},i.readAsArrayBuffer(t)}))}(r):(new TextEncoder).encode(r).buffer;let n=await O(new Uint8Array(i),!1),s=A(n),a=t.getEntry(e);if(a){if(A(a.oid)===s)return a;a.oid=n,t.needSha()}else a=t.addEntry(e,!1,n);return await this.saveBlobNode(s,i,t.fullPath+"/"+e)||a.oid.fill(0),a}async checkoutToLocal(t,e){e.child&&0!==Object.keys(e.child).length||await e.readChild();for(let r of t){let i=r.path;if(r.isDir){let r=await e.mkdir(i),n=t.getEntry(i);if(!n)return void console.error("gitfs 没有这个节点:",i);n.treeNode||await this.openNode(n),await this.checkoutToLocal(n.treeNode,r)}else{let t,n=e.child[i],s=A(r.oid);if(n){let e=await n.readFile("buffer");if(t=await O(e,!0),t==s)continue}if("0000000000000000000000000000000000000000"==s){console.warn("错误文件：",i);continue}let a=await this.getBlobNode(r.oid,"buffer");a?(console.log("gitfs update file:",e.getFullPath()+"/"+i),await e.createFile(i,a)):console.error("下载文件失败。")}}}async rename(t,e){let r=[];if(await this.pathToEntries(t,r)){let t=r[r.length-1];return t.path=e,t.owner.needSha(),!0}return!1}async remove(t){let e=[];if(await this.pathToEntries(t,e)){let t=e[e.length-1];return t.owner.rmEntry(t)}return!1}async removeObject(t){let e=this.getObjUrl(t);await this.frw.rm(e)}copy(t,e){t.addEntry(e.path,e.isDir,e.oid)}async makeCommit(t){if(!this.treeRoot.sha)return console.error("[gitfs] makecommit 需要先计算sha"),null;if(this.curCommit.tree==this.treeRoot.sha)return console.log("[gitfs] makecommit parent 和现在的相同"),null;let e=new U;e.commitMessage=t,e.author=this.user,e.author_timestamp=new Date,e.parent=this.curCommit.sha,e.tree=this.treeRoot.sha,console.log("[gitfs] makecommit tree:",this.treeRoot.sha);let r=new E(e,"nosha"),i=await r.toBuffer(this.frw);return this.curCommit=e,i}async push(t,e){}async saveHeadToLocal(t,e){"object"==typeof t&&(t=JSON.stringify(t));let r=await e.mkdir(C);await r.createFile("head",t)}async getHeadFromLocal(t){await t.readChild();let e=t.child[C];if(!e)return null;await e.readChild();let r=e.child.head;return r?r.readFile("utf8"):r}printCommit(t){console.log("-----------------------------"),console.log(t.commitMessage,t.sha,t.tree)}async printLog(t){let e=this.curCommit;this.printCommit(e);for(let r=0;r<t;r++){let t=e.parent;if(!t)break;if("0"==t)break;let r=await this.getCommit(t);if(!r)break;this.printCommit(r.commitinfo),e=r.commitinfo}}}N.OBJSUBDIRNUM=1,N.MAXFILESIZE=33554432,N.zip=!1,N.touchID=0,function(t){t.TREE="tree",t.BLOB="blob",t.COMMIT="commit"}(x||(x={}));class D{get idstring(){return A(this.oid)}get isDir(){return"0"==this.mode.charAt(0)}constructor(t,e,r){this.packid=null,this.treeNode=null,this.flags=0,this.touchFlag=0,this.path=t,this.mode=e,this.type=L(e),this.oid=r?new Uint8Array(r):D.InvalidOID}get dbgGetTreeNode(){return this.get_treeNode()}async get_treeNode(){if(!this.treeNode){let t=window;if(t.gitfs&&t.gitfs.gitfs){let e=t.gitfs.gitfs;this.treeNode=await e.openNode(this)}}return this.treeNode}modeToInt(){return parseInt(this.mode,16)}}D.dirMode="040000",D.blobMode="100644",D.InvalidOID=new Uint8Array(20);class F{constructor(t,e,r){this._entries=[],this.parent=null,this.buff=null,this.sha=null,this.parent=e,t&&(t instanceof Uint8Array?this.parseBuffer(t,r):Array.isArray(t)&&(this._entries=t.map($)))}get entries(){return this._entries||(this._entries=[]),this._entries}getParentEntry(t){if(t.parent){let e=t.parent.entries;for(let r=0,i=e.length;r<i;r++)if(e[r].treeNode==t)return e[r]}return null}_getFullPath(t,e){let r=this.getParentEntry(t);if(r){let i=e?r.path+"/"+e:r.path;return this._getFullPath(t.parent,i)}return e||"/"}get fullPath(){return this._getFullPath(this,null)}getEntry(t){let e=this._entries;for(let r=0,i=e.length;r<i;r++)if(e[r].path===t)return e[r];return null}addEntry(t,e,r){let i=new D(t,e?D.dirMode:D.blobMode,r?r.slice(0):null);return i.owner=this,this.entries.push(i),this.needSha(),i}rmEntry(t){let e=-1;return"string"==typeof t?e=this.entries.findIndex((e=>e.path==t)):t instanceof D&&(e=this.entries.indexOf(t)),e>=0&&(this.entries.splice(e,1),this.needSha(),!0)}*[Symbol.iterator](){for(const t of this._entries)yield t}needSha(){this.sha=null,this.buff=null,this.parent&&this.parent.needSha()}isNeedSha(){return!this.sha||!this.buff}async updateAllSha(t,e){let r=this.entries;for(let i=0,n=r.length;i<n;i++){let n=r[i],s=n.treeNode;if(s){let r=await s.updateAllSha(t,e);n.oid=v(r)}}return this.isNeedSha()&&(await this.toObject(t),e.push(this)),this.sha}parse_tree(t){let e=this._entries,r=5,i=t.indexOf(0,r);if(-1===i)return console.error("tree后面没有找到0，格式不对"),null;let n=j(new Uint8Array(t.buffer.slice(r,i)));for(parseInt(n),r=i+1,r=r+3&-4;r<t.length;){const i=t.indexOf(32,r);if(-1===i)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next space character.`);const n=t.indexOf(0,r);if(-1===n)throw new Error(`GitTree: Error parsing buffer at byte location ${r}: Could not find the next null character.`);let s=j(new Uint8Array(t.buffer.slice(r,i)));"40000"===s&&(s="040000");const a=L(s),o=j(new Uint8Array(t.buffer.slice(i+1,n)));if(o.includes("\\")||o.includes("/"))throw"unsafe path:"+o;const l=new Uint8Array(t.buffer.slice(n+1,n+21));r=n+21,r=r+3&-4;let c=new Uint32Array(t.buffer,r,2),h=c[0],f=c[1],d=new Date(4294967296*h+f);r+=8;let u=new D(o,s,l);u.fileMTime=d,u.owner=this,u.type=a,e.push(u)}return e}parseBuffer(t,e){let r;return this.buff=t,r=N.zip?new Uint8Array(e.unzip(t.buffer)):new Uint8Array(t.buffer),this._entries.length=0,116==r[0]&&114==r[1]&&101==r[2]&&101==r[3]&&32==r[4]?this.parse_tree(r):null}async toObject(t){const e=this._entries?[...this._entries]:[];e.sort(T);let r=0,i=0;e.map((t=>{let e=t.mode.replace(/^0/,"");i+=e.length,i+=1;let r=(new TextEncoder).encode(t.path).length;i+=r,i+=1,i+=20,i=i+3&-4,i+=8})),r=5+i.toString().length+1,r=(r+3&-4)+i;let n=new Uint8Array(r),s=k(n,"tree ",0);s+=k(n,i.toString(),s),n[s]=0,s+=1,s=s+3&-4;let a=[];e.map((t=>{var e;let r=t.mode.replace(/^0/,"");if(s+=k(n,r,s),n[s]=32,s+=1,s+=k(n,t.path,s),n[s]=0,s+=1,t.oid&&t.oid!=D.InvalidOID){if(!(t.oid instanceof Uint8Array))throw"oid type error";n.set(t.oid,s)}else if(null===(e=t.treeNode)||void 0===e?void 0:e.sha){let e=v(t.treeNode.sha);if(20!=e.byteLength)throw"oid length error";n.set(e,s)}s+=20,s=s+3&-4;let i=t.fileMTime?t.fileMTime.valueOf():0,o=Math.floor(i/4294967296),l=4294967295&i,c=new Uint32Array(n.buffer,s,2);a.push(c,o,l),s+=8})),this.sha=await O(n,!0);for(let t=0;t<a.length/3;t++){let e=a[3*t];e[0]=a[3*t+1],e[1]=a[3*t+2]}return t&&N.zip&&(n=new Uint8Array(t.zip(n.buffer))),this.buff=n,n}}function T(t,e){return function(t,e){return-(t<e)||+(t>e)}(B(t),B(e))}function B(t){return"040000"===t.mode?t.path+"/":t.path}function L(t){switch(t){case"040000":return x.TREE;case"100644":case"100755":case"120000":return x.BLOB;case"160000":return x.COMMIT}throw new Error(`Unexpected GitTree entry mode: ${t}`)}let M=/^0?4.*/,I=/^1006.*/,R=/^1007.*/,z=/^120.*/,W=/^160.*/;function $(t){return t.mode=function(t){if("number"==typeof t&&(t=t.toString(8)),t.match(M))return"040000";if(t.match(I))return"100644";if(t.match(R))return"100755";if(t.match(z))return"120000";if(t.match(W))return"160000";throw new Error(`Could not understand file mode: ${t}`)}(t.mode),t.type||(t.type=L(t.mode)),t}class J{constructor(){this.fileCounts=0,this.version="1.0.0"}}class K{constructor(t,e,r){this.packPath="packfile/",this._frw=e;let i="tree"==t?"tree-":"blob-";this._idxFile=this.packPath+i+r+".idx",this._packFile=this.packPath+i+r+".pack"}async init(){try{this.idxInfo=JSON.parse(await this._frw.read(this._idxFile,"utf8",!0))}catch(t){throw"open pack error"}return!0}async has(t){return this.idxInfo.some((e=>e.id===t))}async get(t){const e=this.idxInfo.find((e=>e.id===t));if(!e)throw new Error(`Object ID ${t} not found`);return await this.readPart(this._packFile,e.start,e.start+e.length)}async readPart(t,e,r){return(await this._frw.read(t,"buffer",!0)).slice(e,r)}}class Z{constructor(){this.version=1,this.xorKey=null}static wrapObject(t,e){let r=new Uint8Array(t.byteLength+24);r.set(Z.FLAG,0);let i=new DataView(r.buffer);return i.setUint32(8,e.version,!0),r.set(e.xorKey||new Uint8Array(8),12),i.setUint32(20,t.byteLength,!0),Z.xorEncryptArrayBuffer(t,0,e.xorKey,r.buffer,24),r}static unwrapObject(t,e){let r=new Uint8Array(t,0,8),i=!0;for(let t=0;t<8;t++)if(r[t]!=Z.FLAG[t]){i=!1;break}if(!i)return null;let n=new DataView(t);e.version=n.getUint32(8,!0);let s=new Uint8Array(t,12,8),a=n.getUint32(20,!0),o=!1;for(let t=0;t<s.length;t++)if(0!=s[t]){o=!0;break}if(o)return e.xorKey=s,Z.xorEncryptArrayBuffer(t,24,s,null,0).buffer;{e.xorKey=null;let r=t.slice(24);if(r.byteLength!=a)throw"unmatched size";return r}}static xorEncryptArrayBuffer(t,e,r,i,n){if(8!==r.length)throw new Error("Key must be exactly 8 characters long.");const s=new Uint8Array(t,e),a=i?new Uint8Array(i,n):new Uint8Array(s.length);for(let t=0;t<s.length;t++)a[t]=s[t]^r[t%r.length];return a}}Z.FLAG=new Uint8Array([108,97,121,97,100,99,99,50]);class G{constructor(){this.mergeFile=!1,this.fileToMerge=102400,this.mergedFileSize=1024e3,this.dccout="dccout",this.outfile="version",this.version="1.0.0",this.fast=!0,this.xorKey=null}}class q{constructor(){this.config=new G}set params(t){this.config=t}async genDCC(t){let e=this.dccout=r.resolve(t,this.config.dccout);if(this.frw=new a,await this.frw.init(e,null),this.gitfs=new N(this.frw),this.config.xorKey){if(this.config.mergeFile)throw"Once encryption is enabled, small file merging cannot be configured";this.gitfs.objectEncrypter={encode:t=>{let e=new Z;return e.xorKey=this.config.xorKey,Z.wrapObject(t,e).buffer},decode:t=>null}}n.existsSync(e)||n.mkdirSync(e,{recursive:!0});let i,s=r.join(e,"revisions");n.existsSync(s)||n.mkdirSync(s);try{let t=await this.frw.read("head.json","utf8",!0),e=JSON.parse(t);if(e.treePackages)for(let t of e.treePackages){let e=new K("tree",this.frw,t);await e.init(),this.gitfs.addObjectPack(e)}i=await this.gitfs.getTreeNode(e.root,null)}catch(t){i=new F(null,null,this.frw)}let o=0,l=null;try{o=parseInt(n.readFileSync(r.join(s,"head.txt"),"utf-8")),o>=0&&(l=n.readFileSync(r.join(s,`${o}.txt`),"utf-8")),l||(o=0)}catch(t){}let c=await this.syncWithDir(t,i,this.config.fast,[".git",".gitignore","dccout"]);i.sha!==l&&(n.writeFileSync(r.join(s,"head.txt"),`${o+1}`),n.writeFileSync(r.join(s,`${o+1}.txt`),i.sha));let h=new J;if(h.root=i.sha,h.fileCounts=c.length,h.objPackages=[],h.time=new Date,h.version=this.config.version,this.config.desc&&(h.desc=this.config.desc),this.config.mergeFile){let t=await this.mergeSmallFile(i,!0,!1);h.treePackages=t.tree_packs}await this.frw.write("head.json",JSON.stringify(h),!0),await this.frw.write(`${this.config.outfile}.${this.config.version}.json`,JSON.stringify(h),!0)}async saveTreePack(t,e,i){let s=this.dccout,a=await O(new Uint8Array(t,e),!0),o=r.join(s,"packfile",`tree-${a}.pack`),l=r.join(s,"packfile",`tree-${a}.idx`);return n.existsSync(r.join(s,"packfile"))||n.mkdirSync(r.join(s,"packfile")),await this.frw.write(o,t.slice(0,e),!0),await this.frw.write(l,JSON.stringify(i),!0),a}async mergeSmallFile(t,e,r){this.dccout;let i=this.frw,n=this.gitfs,s=[],a=[],o=[];await n.visitAll(t,(async t=>{s.push(t.sha)}),(async t=>{a.push(A(t.oid))})),s.length&&(s=[...new Set(s)]),a.length&&(a=[...new Set(a)]);let l=0,c=new Uint8Array(this.config.mergedFileSize),h=[];for(let t of s){let r=n.getObjUrl(t),s=await i.read(r,"buffer",!0),a=s.byteLength;l+a<this.config.mergedFileSize?(h.push({id:t,start:l,length:a}),c.set(new Uint8Array(s),l),l+=a):(o.push(await this.saveTreePack(c,l,h)),l=0,h.length=0,h.push({id:t,start:l,length:a}),c.set(new Uint8Array(s),l),l+=a),e&&await this.frw.rm(r)}return o.push(await this.saveTreePack(c,l,h)),l=0,h.length=0,{tree_packs:o}}async syncWithDir(t,e,s,a=null){let o=[];const l=await(0,i.promisify)(n.readdir)(t,{withFileTypes:!0});let c=r.join(t,".ignore");if(n.existsSync(c)){let t=n.readFileSync(c,"utf-8");t&&(a||(a=[]),t.split("\n").forEach((t=>{t.endsWith("\r")&&(t=t.substring(0,t.length-1)),a.push(t)})))}for(const i of l){let l=i.name;const c=r.resolve(t,l);let h=e.getEntry(l);if(!a||!a.some((t=>l==t)))if(i.isDirectory()){if(h){if(!h.treeNode)try{h.treeNode=await this.gitfs.getTreeNode(A(h.oid),null)}catch(t){let r=new F(null,e,this.frw);h.treeNode=r,e.needSha()}}else{h=e.addEntry(l,!0,null);let t=new F(null,e,this.frw);h.treeNode=t}h.touchFlag=0;let t=await this.syncWithDir(c,h.treeNode,s,[]);h.oid=v(h.treeNode.sha),o=o.concat(t)}else{let t=!0,r=n.statSync(c),i=r.mtime;if(h&&s&&r.mtime<=h.fileMTime&&(t=!1),t){let t=await this.frw.read(c,"buffer",!0);h=await this.gitfs.setFileAtNode(e,l,t),h.fileMTime=i}h.touchFlag=0,o.push(c)}}let h=await e.toObject(this.frw);return await this.gitfs.saveObject(e.sha,h.buffer),o}async checkout(t,e){let r=this.gitfs;await r.checkoutToLocal(null,null)}get fileIO(){return this.frw}getObjectUrl(t){return this.gitfs.getObjUrl(t)}async transUrl(t){let e=this.gitfs;return e&&await e.pathToObjPath(t)||null}}const H=require("os");class V{async getRes(t,e){return conch.readFileFromAsset(t,e)}}class X{constructor(t){this.repoPath=t}init(t,e){throw new Error("Method not implemented.")}fetch(t){throw new Error("Method not implemented.")}async read(t,e,r){let i=this.repoPath+"/"+t;return conch.readFileFromAsset(i,e)}write(t,e,r){throw new Error("Method not implemented.")}isFileExist(t){throw new Error("Method not implemented.")}unzip(t){throw new Error("Method not implemented.")}zip(t){throw new Error("Method not implemented.")}textencode(t){throw new Error("Method not implemented.")}textdecode(t,e){throw new Error("Method not implemented.")}rm(t){throw new Error("Method not implemented.")}enumCachedObjects(t){throw new Error("Method not implemented.")}mv(t,e){throw new Error("Method not implemented.")}}class Y{}Y.log=!0;class Q{constructor(){this.repoPath="",this.dbName="filesDB",this.storeName="files",this.dbVersion=1,this.db=null}fetch(t){throw new Error("Method not implemented.")}async init(t,e){return new Promise(((t,e)=>{if(!window.indexedDB)return console.error("Your browser doesn't support IndexedDB"),void e("Your browser doesn't support IndexedDB");const r=indexedDB.open(this.dbName,this.dbVersion);r.onerror=t=>{console.error("Database error: ",t.target.error),e(t.target.error)},r.onsuccess=e=>{this.db=e.target.result,t()},r.onupgradeneeded=t=>{t.target.result.createObjectStore(this.storeName,{keyPath:"url"})}}))}async read(t,e,r){return new Promise(((r,i)=>{if(!this.db)return void i("Database not initialized");const n=this.db.transaction([this.storeName]).objectStore(this.storeName).get(t);n.onerror=function(t){i("Unable to retrieve data")},n.onsuccess=function(t){if(n.result&&n.result.content){const t=n.result.content;r("string"==typeof t?"utf8"===e?t:(new TextEncoder).encode(t):"buffer"==e?t:(new TextDecoder).decode(t))}else i("URL not found")}}))}async write(t,e,r=!0){return new Promise((async(i,n)=>{if(!this.db)return void n("Database not initialized");const s=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName);if(r)this.storeData(s,t,e,i,n);else{const r=s.get(t);r.onsuccess=()=>{r.result?n("File already exists and overwrite is false"):this.storeData(s,t,e,i,n)}}}))}storeData(t,e,r,i,n){let s={url:e,content:r};const a=t.put(s);a.onsuccess=()=>i(),a.onerror=()=>n("Could not write to store")}async isFileExist(t){return new Promise(((e,r)=>{if(!this.db)return void r("Database not initialized");const i=this.db.transaction([this.storeName]).objectStore(this.storeName).get(t);i.onsuccess=()=>{e(!!i.result)},i.onerror=()=>{r("Could not check file existence")}}))}unzip(t){return t}zip(t){return t}textencode(t){return(new TextEncoder).encode(t)}textdecode(t,e=0){return(new TextDecoder).decode(t)}async mv(t,e){try{const r=await this.read(t,"buffer",!0);await this.write(e,r),await this.delete(t)}catch(t){throw new Error("Move operation failed")}}async delete(t){return new Promise(((e,r)=>{if(!this.db)return void r("Database not initialized");const i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).delete(t);i.onsuccess=()=>e(),i.onerror=t=>r("Delete operation failed: "+t)}))}async rm(t){await this.delete(t)}async enumCachedObjects(t){return new Promise(((e,r)=>{if(!this.db)return void r("Database not initialized");const i=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName).openCursor();i.onerror=function(t){console.error("Error reading data."),r("Failed to open cursor on object store")},i.onsuccess=async r=>{const n=i.result;if(n){let e=n.key;e.startsWith("objects/")&&(e=e.substring(8),e=e.replace(/\//g,""),t(e)),n.continue()}else e()}}))}async deleteAllFiles(){return new Promise(((t,e)=>{if(!this.db)return void e("Database not initialized");const r=this.db.transaction([this.storeName],"readwrite").objectStore(this.storeName),i=r.openCursor();i.onerror=function(t){console.error("Error reading data."),e("Failed to open cursor on object store")},i.onsuccess=async e=>{const n=i.result;n?(r.delete(n.key).onsuccess=function(){console.log(`Deleted file with url: ${n.key}`)},n.continue()):(console.log("No more entries!"),t())}}))}}class tt{constructor(t,e=null){this.dcc=t,this._logger=e}injectToLaya(){if(this.myDownloader&&Laya.Loader.downloader==this.myDownloader)return;this.originDownloader=Laya.Loader.downloader;let t=this.myDownloader=new Laya.Downloader;t.audio=this.audio.bind(this),t.image=this.image.bind(this),t.common=this.common.bind(this),t.imageWithBlob=this.imageWithBlob.bind(this),t.imageWithWorker=this.imageWithWorker.bind(this),Laya.Loader.downloader=t}removeFromLaya(){Laya.Loader.downloader==this.myDownloader&&(Laya.Loader.downloader=this.originDownloader)}injectToNativeFileReader(){let t=window;t.downloadfile!=this.myNativeDownloadFunc&&(this.originNativeDownloader=t.downloadfile,this.myNativeDownloadFunc=(t,e,r,i)=>{let n=t.indexOf("?");n>0&&(t=t.substring(0,n)),this.dcc.readFile(t).then((t=>{r(l.dcodeUtf8(t))}),(t=>{i()}))},t.downloadfile=this.myNativeDownloadFunc)}removeFromNative(){let t=window;t.downloadfile==this.myNativeDownloadFunc&&(t.downloadfile=this.originNativeDownloader)}imageWithBlob(t,e,r,i,n){this._logger&&this._logger.checkLog(`download:imageWithBlob:${r}`),this.originDownloader.imageWithBlob.call(this.originDownloader,t,e,r,i,n)}imageWithWorker(t,e,r,i,n){this._logger&&this._logger.checkLog(`download:imageWithWorker:${r}`),this.originDownloader.imageWithWorker.call(this.originDownloader,t,e,r,i,n)}audio(t,e,r,i,n){this._logger&&this._logger.checkLog(`download:audio:${r}`),this.originDownloader.audio.call(this.originDownloader,t,e,r,i,n)}common(t,e,r,i,n,s){let a;this._logger&&this._logger.checkLog(`download:common:${r}`),this.dcc.onlyTransUrl?(a=this.dcc.transUrl(e),this._logger&&this._logger.checkLog(`download:common:onlyTransUrl:${r}`)):a=(async()=>{let t=await this.dcc.readFile(e);if(!t)return this._logger&&this._logger.checkLog(`download:common:readFile(${e}) error`),e;switch(this._logger&&this._logger.checkLog(`download:common:readFile(${e}) OK`),i){case"text":return s(l.dcodeUtf8(t)),null;case"json":return s(JSON.parse(l.dcodeUtf8(t))),null;case"arraybuffer":return s(t),null;default:var r=new Blob([t],{type:"application/octet-binary"});return window.URL.createObjectURL(r)}})(),a.then((e=>{e&&(this.originDownloader.common.call(this.originDownloader,t,e,r,i,n,s),this._logger&&this._logger.checkLog(`download:common:originCommon(${r})`))}))}image(t,e,r,i,n){let s;s=this.dcc.onlyTransUrl?this.dcc.transUrl(e):(async()=>{let t=await this.dcc.readFile(e);if(!t)return e;var r=new Blob([t],{type:"application/octet-binary"});return window.URL.createObjectURL(r)})(),s.then((e=>{this.originDownloader.image.call(this.originDownloader,t,e,r,i,n)}))}}class et{constructor(t="cache"){this.resReader=new V,this.treePacks=[],this.blobPacks=[],t.startsWith("/")&&(t=t.substring(1)),t.endsWith("/")&&(t=t.substring(0,t.length-1)),this.cachePath=t}async init(){try{let t=new X(this.cachePath),e=await t.read("head.json","utf8",!0);if(!e)return!1;let r=JSON.parse(e);if(r.treePackages)for(let e of r.treePackages){let r=new K("tree",t,e);await r.init(),this.treePacks.push(r)}if(r.objPackages)for(let e of r.objPackages){let r=new K("blob",t,e);await r.init(),this.blobPacks.push(r)}}catch(t){return!1}return!0}async has(t){let e=this.cachePath+"/objects/"+t.substring(0,2)+"/"+t.substring(2);for(let e of this.treePacks)if(e&&await e.has(t))return!0;for(let e of this.blobPacks)if(e&&await e.has(t))return!0;return!!await this.resReader.getRes(e,"buffer")}async get(t){let e=await this._get(t),r=new Z;return Z.unwrapObject(e,r)||e}async _get(t){let e,r=this.cachePath+"/objects/"+t.substring(0,2)+"/"+t.substring(2);for(let r of this.treePacks)if(r&&(await r.has(t)&&(e=await r.get(t)),e))return rt(`Get Object from TreePack:${t}`),e;for(let r of this.blobPacks)if(r&&(await r.has(t)&&(e=await r.get(t)),e))return rt(`Get Object from TreePack:${t}`),e;return await this.resReader.getRes(r,"buffer")}}function rt(t){Y.log&&console.log(t)}class it{split(t){let e=new Uint32Array(t,0,3),r=(e[0],e[1]),i=0;if(t.byteLength!=r+4)return i=1,[null,null,i];let n=e[2];if(n%28!=0)throw"bad buffer";let s=n/28,a=[],o=12;for(let e=0;e<s;e++){let e=A(new Uint8Array(t,o,20));o+=20;let r=new Uint32Array(t,o,4)[0];o+=4;let i=new Uint32Array(t,o,4)[0];o+=4,a.push({id:e,start:r,length:i})}return[a,t,i]}}class nt{constructor(){this.indexObj={}}addObj(t,e){this.indexObj[t]=e.slice(0)}pack(t){t||(t=this.indexObj);let e=[],r=0;for(let e in t){let i=t[e];i&&(r+=i.byteLength)}let i=new Uint8Array(r),n=0;for(let r in t){let s=t[r];s&&(i.set(new Uint8Array(s),n),e.push({id:r,start:n,length:s.byteLength}),n+=s.byteLength)}return[e,i.buffer]}mergeIndexAndContent(t,e){let r;if(t instanceof ArrayBuffer)r=t;else{let e=28,i=t.length*e,n=new Uint8Array(i),s=new Uint32Array(n.buffer);for(let r=0,i=t.length;r<i;r++){const{id:i,start:a,length:o}=t[r];n.set(v(i),r*e),s[r*e/4+5]=a,s[r*e/4+6]=o}r=n.buffer}let i=r.byteLength,n=new Uint8Array(12+r.byteLength+e.byteLength),s=new DataView(n.buffer);return s.setUint32(0,1,!0),s.setUint32(4,n.byteLength-4,!0),s.setUint32(8,i,!0),n.set(new Uint8Array(r),12),n.set(new Uint8Array(e),r.byteLength+12),n.buffer}}function st(t){return new Promise((e=>setTimeout(e,t)))}let at={layaNative:class{getAbsPath(t){let e=conch.getCachePath();return t.includes(":/")||t.includes(":\\")?t:(e.endsWith("/")||(e+="/"),e+t)}makeDirsInCachePath(t){let e=(t=t.replace(/\\/g,"/")).split("/");if(e.pop(),e.length<=0)return;let r=this.getAbsPath("");for(let t of e)r=r+"/"+t,fs_exists(r)||fs_mkdir(r)}async init(t,e){t&&!t.endsWith("/")&&(t+="/"),this.repoPath=t;let r=this.getAbsPath("objects");fs_exists(r)||fs_mkdir(r),Y.log&&console.log("DCCClientFS: path="+conch.getCachePath())}async fetch(t){let e=await function(t,e="buffer"){return new Promise(((r,i)=>{const n=new _XMLHttpRequest;n.responseTypeCode="utf8"==e?1:5,n._open("GET",t,!0),n.setPostCB((t=>{r(t)}),(t=>{r(null)})),n.getData(t)}))}(t);return{ok:!!e,arrayBuffer:async()=>e,text:async()=>l.dcodeUtf8(e)}}async read(t,e,r){let i;try{i=fs_readFileSync(this.getAbsPath(t)),i&&"utf8"==e&&(i=l.dcodeUtf8(i))}catch(t){}if(!i){if(r)return null;if(this.repoPath){let r=await this.fetch(this.repoPath+t);i="utf8"==e?await r.text():await r.arrayBuffer(),await this.write(t,i)}}return i}async write(t,e,r){this.makeDirsInCachePath(t),t=this.getAbsPath(t),!r&&fs_exists(t)||fs_writeFileSync(t,e)}async isFileExist(t){return Promise.resolve().then((()=>fs_exists(t)))}async mv(t,e){throw"native no mv"}unzip(t){throw new Error("Method not implemented.")}zip(t){throw new Error("Method not implemented.")}textencode(t){return(new TextEncoder).encode(t)}textdecode(t,e){return l.dcodeUtf8(t)}async rm(t){t=this.getAbsPath(t),fs_rm(t)}async enumCachedObjects(t){let e=this.getAbsPath("objects"),r=fs_readdirSync(e);for(let i of r){let r=fs_readdirSync(e+"/"+i);for(let e of r)t(i+e)}}},web:class{async init(t,e){t&&!t.endsWith("/")&&(t+="/"),this.repoPath=t,this.dbfile=new Q,await this.dbfile.init("","")}async fetch(t){return await fetch(t)}async read(t,e,r){let i;try{i=await this.dbfile.read(t,e,!0)}catch(n){if(r)return null;if(this.repoPath){let r=await fetch(this.repoPath+t);"utf8"==e?(i=await r.text(),await this.dbfile.write(t,i)):(i=await r.arrayBuffer(),await this.dbfile.write(t,i))}}return i}async write(t,e,r){!r&&await this.dbfile.isFileExist(t)||this.dbfile.write(t,e)}async isFileExist(t){return await this.dbfile.isFileExist(t)}async mv(t,e){await this.dbfile.mv(t,e)}unzip(t){throw new Error("Method not implemented.")}zip(t){throw new Error("Method not implemented.")}textencode(t){return(new TextEncoder).encode(t)}textdecode(t,e){return(new TextDecoder).decode(t)}async rm(t){await this.dbfile.rm(t)}async enumCachedObjects(t){await this.dbfile.enumCachedObjects(t)}},node:null}[l.runtimeName];class ot{constructor(t,e=null,r=null){if(this._onlyTransUrl=!1,this._pathMapToDCC="",this._logger=null,this.dccPathInAssets="cache/dcc2.0",this._loadedPacks={},t&&!t.endsWith("/")&&(t+="/"),this._dccServer=t,e||(e=at),!e)throw"没有正确的文件访问接口";this._frw=new e,r&&(this._logger=r,r.clear()),this.checkEnv()}enableLog(t){Y.log=t}checkEnv(){if(window.conch){if(!ZipFile)throw"native 环境不对";if(!_XMLHttpRequest)throw"native 环境不对";if(!conch.getCachePath)throw"native 环境不对";if(!fs_exists)throw"native 环境不对";if(!fs_mkdir)throw"native 环境不对";if(!fs_readFileSync)throw"native 环境不对";if(!fs_writeFileSync)throw"native 环境不对";if(!fs_rm)throw"native 环境不对";if(!fs_readdirSync)throw"native 环境不对"}}get fileIO(){return this._frw}log(t){Y.log&&console.log(t),this._logger&&this._logger.checkLog(t)}set pathMapToDCC(t){this._pathMapToDCC=t}get pathMapToDCC(){return this._pathMapToDCC}async init(t,e){if(this._gitfs)throw"重复初始化";if(await this._frw.init(this._dccServer,e),window.conch){let t=new V;try{let e=await t.getRes(this.dccPathInAssets+"/head.json","buffer");e&&await this._frw.write("head.json",e,!0)}catch(t){Y.log&&console.log("LayaDCCClient init error: no head.json in package")}}let r,i=null;try{let t=await this._frw.read("head.json","utf8",!0);i=JSON.parse(t).root,r=i}catch(t){}try{let t=[],e=await this._frw.read("downloaded_packs.json","utf8",!0);if(e&&(t=JSON.parse(e),t&&t.length))for(let e of t)this._loadedPacks[e]=1}catch(t){}let n=null,s=null;try{if(t){let e=await this._frw.fetch(t),i=0;for(;!e.ok;){if(e=await this._frw.fetch(t),i++,i>10)return!1;st(100)}s=await e.text(),n=JSON.parse(s),r=n.root}}catch(t){}if(!n&&!i)return!1;let a=this._gitfs=new N(this._frw);if(window.conch){let t=new et(this.dccPathInAssets);await t.init(),a.addObjectPack(t)}if((!i||n&&i!=n.root)&&n.treePackages&&n.treePackages.length){this.log("需要下载treenode");for(let t of n.treePackages){if(this._loadedPacks[t]){this.log(`包已经下载过了${t}`);continue}this.log(`下载treenode:${t}`);let e=await this._frw.fetch(`${this._dccServer}packfile/tree-${t}.idx`);if(!e.ok)throw"download treenode idx error";let r=JSON.parse(await e.text()),i=await this._frw.fetch(`${this._dccServer}packfile/tree-${t}.pack`);if(!i.ok)throw"download treenode pack error";let n=await i.arrayBuffer();for(let t of r){let e=n.slice(t.start,t.start+t.length);await this._gitfs.saveObject(t.id,e)}}}try{if(!await a.setRoot(r))return!1;if(n&&n.treePackages){for(let t of n.treePackages)this._loadedPacks[t]=1;await this._frw.write("downloaded_packs.json",JSON.stringify(Object.keys(this._loadedPacks)),!0)}s&&await this._frw.write("head.json",s,!0)}catch(t){return!1}return!0}set onlyTransUrl(t){this._onlyTransUrl=t}get onlyTransUrl(){return this._onlyTransUrl}async unpackBuffer(t,e,r=0){for(let i of t){let t=e.slice(i.start+r,i.start+r+i.length);await this._gitfs.saveObject(i.id,t)}}async readFile(t){let e=this._gitfs;if(!e)throw"dcc没有正确init";if(t.startsWith("http:")||t.startsWith("https:")||t.startsWith("file:"))if(this._pathMapToDCC){if(!t.startsWith(this._pathMapToDCC))return null;t=t.substring(this._pathMapToDCC.length)}else t=new URL(t).pathname;return await e.loadFileByPath(t,"buffer")}async getObjectUrl(t){return this._gitfs.getObjUrl(t)}async transUrl(t){let e=this._gitfs;if(!e)return t;if(this._pathMapToDCC){if(!t.startsWith(this._pathMapToDCC))return t;t=t.substring(this._pathMapToDCC.length)}else t=new URL(t).pathname;let r=await e.pathToObjPath(t);return r?this._frw.repoPath+r:t}async updateAll(t){let e=this._gitfs,r=new Set;await this._frw.enumCachedObjects((t=>{r.add(t)}));let i=[];await e.visitAll(e.treeRoot,(async t=>{r.has(t.sha)||await this._frw.read(e.getObjUrl(t.sha),"buffer",!1)}),(async t=>{let e=A(t.oid);r.has(e)||i.push(e)})),this.log(`updateAll need update ${i.length}`),t&&t(0);for(let r=0,n=i.length;r<n;r++){let s=i[r];await this._frw.read(e.getObjUrl(s),"buffer",!1),this.log(`updateAll: update obj:${s}`),t&&t(r/n)}t&&t(1)}async updateByZip(t,e,r){let i=new e;i.open(t),i.forEach((async t=>{"head.json"==t.entryName||await this.addObject(t.entryName,t.getData())}));try{let t=i.getEntry("head.json");await this._frw.write("head.json",t.getData().buffer,!0);let e=await this._frw.read("head.json","utf8",!0),r=JSON.parse(e);await this._gitfs.setRoot(r.root)}catch(t){}}async updateByPack(t,e){let r,i,n;if("string"==typeof t){let e=await this._frw.fetch(t);i=await e.arrayBuffer()}else{if(!(t instanceof ArrayBuffer))throw"bad param";i=t}let s=e?new it:new e;const[a,o,l]=s.split(i);r=a,n=o;for(let t of r){let e=n.slice(t.start,t.start+t.length);await this._gitfs.saveObject(t.id,e)}}async addObject(t,e){return this._gitfs.saveObject(t,e)}async clean(){let t=this._gitfs,e=new Set;await t.visitAll(t.treeRoot,(async t=>{e.add(t.sha)}),(async t=>{e.add(A(t.oid))}));let r=[];await this._frw.enumCachedObjects((t=>{e.has(t)||r.push(t)}));for(let e of r)Y.log&&console.log("清理节点:",e),t.removeObject(e);this._loadedPacks={},await this._frw.write("downloaded_packs.json","{}",!0)}async visitAll(t,e){await this._gitfs.visitAll(this._gitfs.treeRoot,t,e)}injectToLaya(){this._downloader||(this._downloader=new tt(this,this._logger)),this._downloader.injectToLaya()}removeFromLaya(){this._downloader&&this._downloader.removeFromLaya()}injectToNativeFileReader(){this._downloader||(this._downloader=new tt(this,this._logger)),this._downloader.injectToNativeFileReader()}removeFromNative(){this._downloader&&this._downloader.removeFromNative()}_jsdown(t,e){this.onlyTransUrl?this.transUrl(t).then((t=>{conch.downloadNoCache(t,(()=>{}),((t,r,i)=>{e.onDownloadEnd(t,"")}),(()=>{}))})):this.readFile(t).then((r=>{this.transUrl(t).then((t=>{let i=t.substring(this._dccServer.length),n=conch.getCachePath()+"/"+i;e.onDownloadEnd(r,n)}))}))}injectToNative3(){conch.setDownloader(this._jsdown.bind(this))}}ot.VERSION="1.0.0";class lt{constructor(){this.cachePath="d:/temp/dcctest/cache/"}async init(t,e){this.repoPath=t,e&&(this.cachePath=e),await(0,i.promisify)(n.mkdir)(r.join(this.cachePath,"objects"),{recursive:!0})}async read(t,e,s){if(r.isAbsolute(t))throw"DCCClientFS_NodeJS 只支持读取相对目录";let a,o=r.join(this.cachePath,t);try{a=await(0,i.promisify)(n.readFile)(o),"utf8"==e&&(a=l.dcodeUtf8(a))}catch(t){}if(!a){if(s)return null;if(this.repoPath){let r=await this.fetch(this.repoPath+t);a="utf8"==e?await r.text():await r.arrayBuffer(),await this.write(t,a)}}return a}async fetch(t){if(t.startsWith("file:///")&&(t=t.replace("file:///","")),r.isAbsolute(t)){let e=n.readFileSync(t);return{ok:!0,arrayBuffer:async()=>e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength),text:async()=>(new TextDecoder).decode(e)}}throw"xx1"}async write(t,e,s){if(r.isAbsolute(t))throw"only rel";let a=t.split("/");a.pop();let o=r.resolve(this.cachePath,t),l=r.resolve(this.cachePath,a.join("/"));try{if(!s&&n.existsSync(o))return;await(0,i.promisify)(n.access)(l)}catch(t){await(0,i.promisify)(n.mkdir)(l,{recursive:!0})}if(e instanceof ArrayBuffer)return(0,i.promisify)(n.writeFile)(o,Buffer.from(e));await(0,i.promisify)(n.writeFile)(o,e)}async enumCachedObjects(t){let e=r.join(this.cachePath,"objects"),i=n.readdirSync(e);for(let r of i){let i=e+"/"+r,s=n.readdirSync(i);for(let e of s)t(r+e)}}rm(t){let e=r.resolve(this.cachePath,t);return(0,i.promisify)(n.rm)(e)}async isFileExist(t){try{return await(0,i.promisify)(n.access)(t,n.constants.F_OK),!0}catch(t){return!1}}unzip(t){throw new Error("Method not implemented.")}zip(t){throw new Error("Method not implemented.")}textencode(t){return Buffer.from(t,"utf-8").buffer}textdecode(t,e){if(!(t instanceof ArrayBuffer))throw new Error("Input must be an ArrayBuffer.");return Buffer.from(t).toString("utf-8",e)}mv(t,e){return(0,i.promisify)(n.rename)(t,e)}}class ct{async init(t){let e=t,r="head.json";if(t.endsWith(".json")){let i=Math.max(t.lastIndexOf("/"),t.lastIndexOf("\\"));e=t.substring(0,i),r=t.substring(i+1)}this.frw=new a,await this.frw.init(e,null),this.gitfs=new N(this.frw);try{let t=await this.frw.read(r,"utf8",!0),e=JSON.parse(t);if(e.treePackages)for(let t of e.treePackages){let e=new K("tree",this.frw,t);await e.init(),this.gitfs.addObjectPack(e)}await this.gitfs.setRoot(e.root)}catch(t){}}async checkout(t){let e=this.frw;await this.gitfs.visitAll(this.gitfs.treeRoot,(async e=>{let i=r.join(t,e.fullPath);n.existsSync(i)||n.mkdirSync(i)}),(async i=>{let s=A(i.oid);if(i.owner){let a=r.join(t,i.owner.fullPath,i.path),o=await e.read(await this.gitfs.getObjUrl(s),"buffer",!0);n.writeFileSync(a,Buffer.from(o)),i.fileMTime&&n.utimesSync(a,i.fileMTime,i.fileMTime),console.log("checkout file:",a)}}))}}class ht{static genDCC(t,e,r){}static genZipPatch(t){!function(t){let e=[],i=r.resolve(t,"objects"),s=n.readdirSync(i);for(let t of s){let r=i+"/"+t,s=n.readdirSync(r);for(let r of s)e.push(t+r)}}(t)}static async genZipByPath(t,e){let s=r.join(H.tmpdir(),"layadcc");try{await(0,i.promisify)(n.mkdir)(s)}catch(t){}let a=r.join(s,"_tempdccout_dir_pack");n.existsSync(a)&&n.rmdirSync(a,{recursive:!0}),await(0,i.promisify)(n.mkdir)(a);let o=new q,l=new G;l.mergeFile=!1,o.params=l,l.dccout=a,await o.genDCC(t);let c=new IEditor.ZipFileW(e);o.fileIO.enumCachedObjects((t=>{let e=r.join(l.dccout,o.getObjectUrl(t)),i=n.readFileSync(e);c.addBuffer(t,new Uint8Array(i))})),await c.save(e),n.rmdirSync(l.dccout,{recursive:!0})}static async genPackByFileList(t,e,r){let i=new r,n=new a;for(let e of t){let t=await n.read(e,"buffer",!0),r=A(await O(new Uint8Array(t),!1));i.addObject(r,new Uint8Array(t))}await i.save(e)}static async genZipByComparePath(t,e,s,a){let o=r.join(H.tmpdir(),"layadcc");try{await(0,i.promisify)(n.mkdir)(o)}catch(t){}let l=new ot(t,lt);await l.init(r.join(t,"head.json"),o+"/zip/cache1");let c=new ot(e,lt);await c.init(r.join(e,"head.json"),o+"/zip/cache2");let h=[],f=[];console.log("开始统计",t),await l.updateAll(null),await l.fileIO.enumCachedObjects((t=>{h.push(t)})),console.log("开始统计",e),await c.updateAll(null),await c.fileIO.enumCachedObjects((t=>{f.push(t)})),console.log("比较差异...");let d=[],u=new Set;h.forEach((t=>{u.add(t)})),f.forEach((t=>{u.has(t)||d.push(t)})),console.log(`发现差异文件${d.length}个.`),console.log("写文件..."),n.mkdirSync(s,{recursive:!0});let w=r.join(s,null!=a?a:"dcc.zip"),y=new IEditor.ZipFileW(w);for(let t of d)try{let i=r.join(e,await c.getObjectUrl(t));console.log(i);let s=n.readFileSync(i);y.addBuffer(t,new Uint8Array(s))}catch(i){let n=r.join(e,await c.getObjectUrl(t));console.log(n);let s=await c.fileIO.read(await c.getObjectUrl(t),"buffer",!1);y.addBuffer(t,new Uint8Array(s))}return y.addFile(r.join(e,"head.json"),"head.json"),await y.save(w),console.log("删除临时目录：",o),await(0,i.promisify)(n.rmdir)(o,{recursive:!0}),console.log("完成"),w}static async getZipByRev(t,e,r){}static async checkout(t,e){if(!t.endsWith(".json"))throw"checkout的第一个参数是head文件";n.mkdirSync(e,{recursive:!0});let r=new ct;await r.init(t),r.checkout(e)}}class ft{constructor(){this.pack=new nt}addObject(t,e){this.pack.addObj(t,e)}async save(t){const[e,r]=this.pack.pack(null);let i=this.pack.mergeIndexAndContent(e,r);n.writeFileSync(t,Buffer.from(i))}}exports.layadcctools=e})();